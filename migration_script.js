const fs = require('fs');
const path = require('path');

const tsFilePath = path.join(__dirname, 'src', 'data', 'koreanNames.ts');
const outputFilePath = path.join(__dirname, 'koreanNames_new.ts');

// 1. Read the original TypeScript file
const tsFileContent = fs.readFileSync(tsFilePath, 'utf8');

// 2. Extract only the createName() calls
const createNameCalls = tsFileContent.match(/createName\({[\s\S]*?}\)/g);

if (!createNameCalls) {
    console.error("Could not find any createName calls.");
    process.exit(1);
}

// 3. Evaluate the calls in a controlled scope to get the data
const scriptToEval = `
(() => {
  const createName = (params) => params;
  return [
    ${createNameCalls.join(',\n')}
  ];
})();
`;

let KOREAN_NAMES;
try {
    KOREAN_NAMES = eval(scriptToEval);
} catch (e) {
    console.error("Failed to evaluate the extracted data.", e);
    process.exit(1);
}


// --- Start of data processing ---

const createMultilingualField = (defaultValue = '') => ({
  en: defaultValue,
  ko: defaultValue,
  ja: defaultValue,
  zh: defaultValue,
  fr: defaultValue,
  de: defaultValue,
  es: defaultValue,
  ru: defaultValue,
  ar: defaultValue,
  hi: defaultValue,
});

const createDefaultNameStructure = () => ({
  korean: '',
  romanization: '',
  pronunciation: '',
  element: '',
  gender: '',
  popularity: 0,
  meaning: createMultilingualField(),
  story: createMultilingualField(),
  fortune: createMultilingualField(),
  hanjaBreakdown: {
    characters: [],
    traditionalMeaning: createMultilingualField(),
  },
  harmony: createMultilingualField(),
});

const ensureMultilingual = (field) => {
  if (typeof field === 'string') {
    const newField = createMultilingualField();
    newField.en = field;
    newField.ko = field; // Default Korean to English if not present
    return newField;
  }
  if (typeof field === 'object' && field !== null) {
    return { ...createMultilingualField(), ...field };
  }
  return createMultilingualField();
};

const processedNames = KOREAN_NAMES.map(nameObj => {
    const defaultStructure = createDefaultNameStructure();
    const merged = { ...defaultStructure, ...nameObj };

    merged.meaning = ensureMultilingual(merged.meaning);
    merged.story = ensureMultilingual(merged.story);
    merged.fortune = ensureMultilingual(merged.fortune);
    merged.harmony = ensureMultilingual(merged.harmony);

    if (!merged.hanjaBreakdown || typeof merged.hanjaBreakdown !== 'object') {
        merged.hanjaBreakdown = defaultStructure.hanjaBreakdown;
    } else {
        merged.hanjaBreakdown.characters = merged.hanjaBreakdown.characters || [];
        merged.hanjaBreakdown.traditionalMeaning = ensureMultilingual(merged.hanjaBreakdown.traditionalMeaning);
    }
    
    const finalObject = {
        korean: merged.korean,
        romanization: merged.romanization,
        pronunciation: merged.pronunciation,
        element: merged.element,
        gender: merged.gender,
        popularity: merged.popularity,
        meaning: merged.meaning,
        story: merged.story,
        fortune: merged.fortune,
        hanjaBreakdown: merged.hanjaBreakdown,
        harmony: merged.harmony,
    };

    return finalObject;
});

// 6. Reconstruct the final, clean TypeScript file
const newFileContent = `// This file was auto-generated by migration_script.js
// It contains the standardized structure for Korean names.

// A helper function to define the names, matching the desired structure.
const createName = (name) => name;

export const KOREAN_NAMES_NEW = [
${processedNames.map(name => `  createName(${JSON.stringify(name, null, 4)})`).join(',\n')}
];
`;

fs.writeFileSync(outputFilePath, newFileContent, 'utf8');
console.log(`Successfully migrated names to ${outputFilePath}`);