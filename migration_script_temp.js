
const fs = require('fs');
const path = require('path');

const tsFilePath = path.join(__dirname, 'src', 'data', 'koreanNames.ts');
const outputFilePath = path.join(__dirname, 'src', 'data', 'koreanNames_new.ts');

// 1. Read the original TypeScript file
const tsFileContent = fs.readFileSync(tsFilePath, 'utf8');

// 2. Extract only the createName() calls
const createNameCalls = tsFileContent.match(/createName\({[\s\S]*?}\)/g);

if (!createNameCalls) {
    console.error("Could not find any createName calls.");
    process.exit(1);
}

// 3. Evaluate the calls in a controlled scope to get the data
const scriptToEval = `
(() => {
  const createName = (params) => params;
  return [
    ${createNameCalls.join(',\n')}
  ];
})();
`;

let KOREAN_NAMES;
try {
    KOREAN_NAMES = eval(scriptToEval);
} catch (e) {
    console.error("Failed to evaluate the extracted data.", e);
    process.exit(1);
}


// --- Start of data processing ---

const supportedLocales = ['en', 'ko', 'ja', 'zh-CN', 'zh-TW', 'es', 'fr', 'de', 'pt', 'ru'];

const fillMultilingualField = (field) => {
  const newField = {};
  const enValue = field.en || '';

  for (const locale of supportedLocales) {
    // If the field for the locale is missing or empty, use the English value.
    if (!field[locale]) {
      newField[locale] = enValue;
    } else {
      newField[locale] = field[locale];
    }
  }
  
  // Handle zh -> zh-CN, zh-TW
  if (field.zh && (!field['zh-CN'] || !field['zh-TW'])) {
      if(!field['zh-CN']) newField['zh-CN'] = field.zh;
      if(!field['zh-TW']) newField['zh-TW'] = field.zh;
  }
  if (newField.zh) delete newField.zh;


  return newField;
};


const processedNames = KOREAN_NAMES.map(name => {
  // Process meaning
  if (name.meaning) {
    name.meaning = fillMultilingualField(name.meaning);
  }

  // Process hanjaBreakdown
  if (name.hanjaBreakdown) {
    if (name.hanjaBreakdown.characters) {
      name.hanjaBreakdown.characters = name.hanjaBreakdown.characters.map(char => {
        if (char.meaning) {
          char.meaning = fillMultilingualField(char.meaning);
        }
        return char;
      });
    }
    if (name.hanjaBreakdown.traditionalMeaning) {
      name.hanjaBreakdown.traditionalMeaning = fillMultilingualField(name.hanjaBreakdown.traditionalMeaning);
    }
  }

  return name;
});

// 6. Reconstruct the final, clean TypeScript file
const newFileContent = `// This file was auto-generated by migration_script.js
// It contains the standardized structure for Korean names.
import { KoreanName } from './koreanNames';

const createName = (params: KoreanName) => params;

export const KOREAN_NAMES: KoreanName[] = [
${processedNames.map(name => `  createName(${JSON.stringify(name, null, 2)})`).join(',\n')}
];

// Function to get names by criteria
export const getNamesByGender = (gender: 'male' | 'female' | 'neutral'): KoreanName[] => {
  return KOREAN_NAMES.filter(name => name.gender === gender);
};

export const getNamesByElement = (element: 'wood' | 'fire' | 'earth' | 'metal' | 'water'): KoreanName[] => {
  return KOREAN_NAMES.filter(name => name.element === element);
};

export const getNamesByStyle = (style: 'traditional' | 'modern' | 'kpop' | 'mixed'): KoreanName[] => {
  return KOREAN_NAMES.filter(name => name.style === style);
};

export const searchNamesByPronunciation = (englishName: string): KoreanName[] => {
  // Simple phonetic matching - can be improved with more sophisticated algorithm
  const searchTerm = englishName.toLowerCase();
  return KOREAN_NAMES.filter(name =>
    name.pronunciation.toLowerCase().includes(searchTerm.substring(0, 2)) ||
    name.romanization.toLowerCase().includes(searchTerm.substring(0, 2))
  ).sort((a, b) => b.popularity - a.popularity);
};
`;

// Correcting the output path to be inside src/data
fs.writeFileSync(outputFilePath, newFileContent, 'utf8');
console.log(`Successfully migrated names to ${outputFilePath}`);

